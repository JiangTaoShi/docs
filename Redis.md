##### Redis 面试篇

1、什么是 Redis?
Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据
库。
Redis 与其他 key - value 缓存产品有以下三个特点：
⚫ Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时
候可以再次加载进行使用。
⚫ Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，
set，zset，hash 等数据结构的存储。
⚫ Redis 支持数据的备份，即 master-slave 模式的数据备份。


2、Redis 的数据类型？
Redis 支持五种数据类型：string（字符串），hash（哈希），list（列
表），set（集合）及 zsetsorted set：有序集合)。
我们实际项目中比较常用的是 string，hash 如果你是 Redis 中高级用户，还
需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。
如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，
面试官得眼睛就开始发亮了。


3、使用 Redis 有哪些好处？
⚫ 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查
找和操作的时间复杂度都是 O1)
⚫ 支持丰富数据类型，支持 string，list，set，Zset，hash 等
⚫ 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执
行，要么全部不执行
⚫ 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动
删除

4、Redis 相比 Memcached 有哪些优势？
⚫ Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为
丰富的数据类
⚫ Redis 的速度比 Memcached 快很
⚫ Redis 可以持久化其数据



6、Redis 是单进程单线程的？
Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访 问，消
除了传统数据库串行控制的开销。


10、Redis 过期键的删除策略？
（1）定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时
器在键的过期时间来临时，立即执行对键的删除操作。
（2）惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得
的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
（3）定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期
键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

12、为什么 Redis 需要把所有数据放到内存中？
Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式 将数
据写入磁盘。所以 Redis 具有快速和数据持久化的特征。如果不将数据放 在
内存中，磁盘 I/O 速度为严重影响 Redis 的性能。在内存越来越便宜的今 天，
Redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录 数达
到内存限值后不能继续插入新值。

14、Pipeline 有什么好处，为什么要用 Pipeline？
可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之 间没
有因果相关性。使用 Redis-benchmark 进行压测的时候可以发现影响 Redis
的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目


27、怎么理解 Redis 事务？
（1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执
行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
（2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执
行。


30、Redis 如何做内存优化？
尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的
内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比
如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密
码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面


33、Redis 的内存用完了会发生什么？
如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可 以正
常返回。）或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到
内存上限时会冲刷掉旧的内容。

36、Redis 最适合的场景？
会话缓存（Session Cache）
最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓
存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护
一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分
人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的
改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的
商业平台 Magento 也提供 Redis 的插件。

全页缓存（FPC）
除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问
题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载
速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为
例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 此外，对
WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件
能帮助你以最快速度加载你曾浏览过的页面。

队列
Redis 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得
Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，
就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。 如果你快
速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，
这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需
求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去
查看。

排行榜/计数器
Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有
序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis
只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠
前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即
可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户
及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES
Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用
Redis 来存储数据的，你可以在这里看到。

发布/订阅
最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用
场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订
阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！

37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某
个固定的已知的前缀开头的，如果将它们全部找出来？
使用 keys 指令可以扫出指定模式的 key 列表。
对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指
令会有什么问题？
这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会
导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢
复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的
70
key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整
体所花费的时间会比直接用 keys 指令长。


38、如果有大量的 key 需要设置同一时间过期，一般需要注意什
么？
如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis 可能
会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间 分散
一些。

40、使用过 Redis 分布式锁么，它是什么回事
先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘
记了释放。
这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行
expire 之前进程意外 crash 或者要重启维护了，那会怎么样？这时候你要给
予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓
自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回
答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和
expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小
子还不错。


4、用缓存可能出现的问题
⚫ 数据不一致
⚫ 缓存雪崩
⚫ 缓存穿透
⚫ 缓存并发竞争

如果避免缓存”穿透”的问题？
```
缓存穿透，是指查询一个一定不存在的数据，由于缓存是不命中时被动写，并
且处于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在
的数据每次请求都要到 DB 去查询，失去了缓存的意义。

方案一，缓存空对象。
当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用
特殊的标识，能和真正缓存的数据区分开。另外，需要设置较短的过期时间，
一般建议不要超过 5 分钟。
方案二，BloomFilter 布隆过滤器。
在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储
对应的 KEY 是否存在，如果存在，说明该 KEY 对应的值不为空。

```

如何避免缓存“雪崩”的问题？
```
缓存雪崩
缓存雪崩，是指缓存由于某些原因无法提供服务( 例如，缓存挂掉了 )，所有
请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。
如何解决
预防和解决缓存雪崩的问题，可以从以下多个方面进行共同着手。
 1）缓存高可用：通过搭建缓存的高可用，避免缓存挂掉导致无法提供服务的
情况，从而降低出现缓存雪崩的情况。假设我们使用 Redis 作为缓存，则可以
使用 Redis Sentinel 或 Redis Cluster 实现高可用。
 2）本地缓存：如果使用本地缓存时，即使分布式缓存挂了，也可以将 DB 查
询到的结果缓存到本地，避免后续请求全部到达 DB 中。如果我们使用 JVM ，
则可以使用 Ehcache、Guava Cache 实现本地缓存的功能。
```
如果避免缓存“击穿”的问题？
```
缓存击穿
缓存击穿，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间
点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB
加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。
对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高
并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个问题。
区别：
⚫ 和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多
KEY 。
⚫ 和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。

如何解决
有两种方案可以解决：
1）方案一，使用互斥锁。请求发现缓存不存在后，去查询 DB 前，使用分布
式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。
2）方案二，手动过期。缓存上从不设置过期时间，功能上将过期时间存在 KEY
对应的 VALUE 里。流程如下：
⚫ 1、获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则
直接返回；如果已过期，继续往下执行。
⚫ 2、通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过
后台的异步线程，保证有且只有一个线程去查询 DB。
⚫ 3、同时，虽然 VALUE 已经过期，还是直接返回。通过这样的方式，保证
服务的可用性，虽然损失了一定的时效性。
```
